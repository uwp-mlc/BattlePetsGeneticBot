/**
 * This class acts as the controller for the GUI game.
 */
package edu.furbiesfighters.gameplay;

import java.util.ArrayList;
import java.util.List;

import edu.furbiesfighters.damage.Calculatable;
import edu.furbiesfighters.damage.CalculateDamage;
import edu.furbiesfighters.damage.Pair;
import edu.furbiesfighters.events.AttackEvent;
import edu.furbiesfighters.players.Playable;
import edu.furbiesfighters.players.PlayerTypes;
import edu.furbiesfighters.presenters.GamePlayPresenter;
import edu.furbiesfighters.skills.Skills;
import edu.furbiesfighters.utility.Utility;

/**
 * @author Furbies Fighters
 *
 */
public class GUIReferee extends Referee{
	private final int MINIMUM_PLAYERS = 2;
	private boolean stillChosingSkills;
	private List<Playable> currentRound;
	private int fightNumber;
	private int currentAliveIndex;
	private GamePlayPresenter presenter;
	
	public GUIReferee()
	{
		super();
		this.fightNumber = 1;
		stillChosingSkills = true;
		this.currentRound = null;
		this.currentAliveIndex = 0;
		super.damageCalculator = new CalculateDamage(this);
	}
	
	/**
	 * Allows all players to choose their skill. And checks for sleeping
	 * players in the round. 
	 */
	@Override
	public void allChooseSkill()
	{
		/*No operation in GUI version*/
	}

	@Override
	public List<Skills> getCurrentPlayableSkillStringList()
	{
		if(this.currentAliveIndex > this.getAlivePlayables().size()-1)
			return new ArrayList<Skills>();
		Playable currentPlayer = this.getNextPlayerInfo();
		
		String message = currentPlayer.getPlayerName() + " has the following recharging:";
		boolean noRecharging = true;;
		List<Skills> l;
		
		l = new ArrayList<Skills>();
		
		if (currentPlayer.getSkillRechargeTime(Skills.ROCK_THROW) == 0)
		{
			l.add(Skills.ROCK_THROW);
		}
		else
		{
			noRecharging = false;
			message += " " + Skills.ROCK_THROW.toString();
		}
		if (currentPlayer.getSkillRechargeTime(Skills.PAPER_CUT) == 0)
		{
			l.add(Skills.PAPER_CUT);
		}

		else
		{
			noRecharging = false;
			message += " " + Skills.PAPER_CUT.toString();
		}
		if (currentPlayer.getSkillRechargeTime(Skills.SCISSOR_POKE) == 0)
		{
			l.add(Skills.SCISSOR_POKE);
		}
		else
		{
			noRecharging = false;
			message += " " + Skills.SCISSOR_POKE.toString();
		}
		if (currentPlayer.getSkillRechargeTime(Skills.SHOOT_THE_MOON) == 0)
		{
			l.add(Skills.SHOOT_THE_MOON);
		}
		else
		{
			noRecharging = false;
			message += " " + Skills.SHOOT_THE_MOON.toString();
		}
		if (currentPlayer.getSkillRechargeTime(Skills.REVERSAL_OF_FORTUNE) == 0)
		{
			l.add(Skills.REVERSAL_OF_FORTUNE);
		}
		else
		{
			noRecharging = false;
			message += " " + Skills.REVERSAL_OF_FORTUNE.toString();
		}
		
		if(noRecharging)
			message += " (none)\n";
		if(currentPlayer.getPlayerType() != PlayerTypes.AI)
			Utility.printMessage(message);
		
		return l;
	}
		
	private Skills stringToSkillsConversion(String string)
	{
		Skills s;
		
		s = null;
		
		switch (string)
		{
		case "rock throw" :
			s = Skills.ROCK_THROW;
			break;
		case "scissor poke" :
			s = Skills.SCISSOR_POKE;
			break;
		case "paper cut" :
			s = Skills.PAPER_CUT;
			break;
		case "shoot the moon" :
			s = Skills.SHOOT_THE_MOON;
			break;
		case "reversal of fortune" :
			s = Skills.REVERSAL_OF_FORTUNE;
			break;
		}
		
		return s;
	}
	
	public int getRechargeTimeForSkill(Skills s)
	{
		int time;
		
		time = 1;
		
		switch (s)
		{
		case SHOOT_THE_MOON :
			time = this.STM_RECHARGE_TIME;
			break;
		case REVERSAL_OF_FORTUNE :
			time = this.ROF_RECHARGE_TIME;
			break;
		}
		
		return time;
	}
	
	/**
	 * Method for print out the results of the round. It will print out the 
	 * player and their hp.
	 */
	@Override
	public void announceRoundResults()
	{
		List<Playable> playables = getAllPlayables();
		Playable tempPlayable;
		int playerIndex;
		Utility.printMessage("\nSTATUS REPORT:");
		for (int i = 0; i < playables.size(); i++)
		{
			playerIndex = i + 1;
			tempPlayable = playables.get(i);
			String playableMessage = "";
			
			if(!tempPlayable.isAwake())
				playableMessage = "SLEEPING";
			else
				playableMessage += tempPlayable.getCurrentHp();
			
			Utility.printMessage(playerIndex + ". " + tempPlayable.getPlayerName() + ", " + playableMessage);
		}
		Utility.printEndline();
	}
	
	/**
	 * Returns a list of all alive players. This method called after
	 * determining there is a winner. If there is a tie, return null. 
	 * If there is still players left in the game, then this method should
	 * not be called, but return null anyways. 
	 * @return
	 */
	private List<Playable> determineFightWinners()
	{
		List<Playable> playables = getAlivePlayables();
		if(playables.size() >= this.MINIMUM_PLAYERS)
			return null;
		else if(playables.size() == 0)
			return calculateTie();
		getAlivePlayables().forEach(playable-> addFightWonToPlayer(playable));
		return playables;
	}
	
	/**
	 * Method for announcing the information for a fight.
	 */
	private void announceFightResults()
	{
		List<Playable> winners = this.determineFightWinners();
		
		if(winners == null)
			Utility.printMessage("A tie occured in fight " + this.fightNumber);
		else
		{
			Utility.printSmallBanner("Fight Ended");
			Utility.printMessage("Winner(s): ");
		}
		
		String winningString = "";
		for (int i = 0; winners != null && i < winners.size(); i++)
		{
			if(i == winners.size()-1)
				winningString += winners.get(i).getPlayerName();
			else
				winningString += winners.get(i).getPlayerName() + ", ";
		}
		Utility.printMessage(winningString);
		
		Utility.printEndline();
	}
	
	/**
	 * Uses alivePlayerHistory in the round class to get the
	 * list of alive players before the round started.
	 * @return
	 */
	private List<Playable> calculateTie()
	{
		if(this.currentRound == null)
		{
			getAlivePlayables().forEach(playable-> addFightWonToPlayer(playable));
			return getAllPlayables();
		}
		else
		{
			this.currentRound.forEach(playable-> addFightWonToPlayer(playable));
			return this.currentRound;
		}
	}
	
	@Override
	public void play()
	{
		List<Playable> players = this.getAlivePlayables();
		int i = this.currentAliveIndex;
		while( i < players.size() && players.get(i).getPlayerType() == PlayerTypes.AI)
		{
			Skills chosen = players.get(i).chooseSkill();//AI Choose skill
			this.chosenSkills.put(this.getIndexOfPlayable(players.get(i)), chosen);
			this.currentAliveIndex = ++i;
		}

		if(this.currentAliveIndex > players.size()-1)
		{
			this.calculateAllDamages();
			this.announceRoundResults();
			this.currentAliveIndex = 0; //Reset index to zero
		}

		if(this.hasWinner())
		{
			this.announceFightResults();
			System.out.println("HAS WINNER");
			
			this.presenter.setFightNumber(++this.fightNumber);
			if(this.fightNumber >= this.getFightCount())
			{
				System.out.println("ECLIPSE SUCKS");
				this.presenter.showPostBattle();
			}
			
			this.updateHP();
			this.currentAliveIndex = 0;
		}
		else
		{
			play();
		}
	}
	
	@Override
	public void play(String playerName, String skillChoice)
	{
		addChosenHumanSkill(playerName, skillChoice);
			
		play();//play until next human player
	}
	
	@Override
	public void addChosenHumanSkill(String playerName, String skillChoice)
	{
		Skills skill = stringToSkillsConversion(skillChoice);
		
		Playable player = null;
		for(Playable p : this.getAllPlayables())
			if(p.getPlayerName().equals(playerName))
				player = p;
		if(player == null)
			System.out.println("NO PLAYER");
		else
		{
			this.chosenSkills.put(this.getIndexOfPlayable(player), skill);
			this.currentAliveIndex++;
			player.decrementRechargeTimes();
			player.setRechargeTime(skill, getRechargeTimeForSkill(skill));
		}
	}
	
	@Override
	public Playable getNextPlayerInfo()
	{
		return this.getAlivePlayables().get(currentAliveIndex);
	}
	
	@Override
	public void setUpGUI(GamePlayPresenter presenter) 
	{
		this.presenter = presenter;
	}
}
